(* ::Package:: *)

(* ::Input:: *)
(*(*Attempting to solve Eq. (4) to get Fig. 3 of DOI: 10.1103/PhysRevB.88.144507.*)*)
(*Clear["Global`*"]*)
(*$PrePrint=#/.out_->TraditionalForm[out]&;*)
(*Dagger[m_]:=ConjugateTranspose[m]*)
(*MakeReal[xvar_]:={Im[xvar]^=0;Re[xvar]^=xvar;xvar\[Conjugate]^=xvar;}*)


(* ::Input:: *)
(*(*Useful mathematical definitions.*)*)
(*MakeReal[\[Epsilon]];MakeReal[\[Phi]];MakeReal[\[Delta]1];MakeReal[\[Delta]2];MakeReal[\[Delta]p];MakeReal[\[Delta]m];*)
(*ZeroMat[n_]:=ConstantArray[0,{n,n}];*)
(*\[Sigma][n_]:=PauliMatrix[n]*)
(*\[CapitalSigma]1=ArrayFlatten[{{\[Sigma][1],0},{0,Id[2]}}];*)
(*\[Sigma]p={{0,1},{0,0}};*)
(*\[Sigma]m={{0,0},{1,0}};*)
(*Id[n_]:=IdentityMatrix[n]*)
(*antiCommutator[A_,B_]:=(A.B+B.A)*)
(*Commutator[A_,B_]:=(A.B-B.A)*)
(*SetSharedFunction[ParallelSow];*)
(*ParallelSow[expr_]:=Sow[expr]*)


(* ::Input:: *)
(*(*The Majorana operators.*)*)
(*Maj[1]=KroneckerProduct[\[Sigma][1],\[Sigma][1]];*)
(*Maj[2]=KroneckerProduct[\[Sigma][1],\[Sigma][2]];*)
(*Maj[3]=KroneckerProduct[\[Sigma][1],\[Sigma][3]];*)
(*Maj[4]=KroneckerProduct[\[Sigma][2],Id[2]];*)
(**)
(*(*Bare fermions: these will be the quasiparticle operators.*)*)
(*Ann[1]=(1/2)(Maj[1]+I*Maj[2]);*)
(*Ann[2]=(1/2)(Maj[3]+I*Maj[4]);*)
(*Cre[1]=Dagger[Ann[1]];*)
(*Cre[2]=Dagger[Ann[2]];*)
(**)
(*(*BdG Hamiltonian*)*)
(*HBdG=({{2\[Epsilon]*Cos[\[Phi]/2],I*\[Delta]m,0,I*\[Delta]p},{-I*\[Delta]m,0,-I*\[Delta]p,0},{0,I*\[Delta]p,-2\[Epsilon]*Cos[\[Phi]/2],I*\[Delta]m},{-I*\[Delta]p,0,-I*\[Delta]m,0}})/2;*)
(*params2={\[Epsilon]->1,\[Delta]p->1/10,\[Delta]m->1/100};*)
(*\[Epsilon]BdG1=Eigenvalues[HBdG][[2]]//.params2;*)
(*\[Epsilon]BdG2=Eigenvalues[HBdG][[4]]//.params2;*)


(* ::Input:: *)
(*(*This is the low-energy Hamiltonian in terms of Majoranas.*)*)
(*H0m=Simplify[(I*(\[Epsilon])*Cos[\[Phi]/2]*Maj[1].Maj[2]+I*(1/2)(\[Delta]p+\[Delta]m)*Maj[1].Maj[3]+I*(1/2)(\[Delta]p-\[Delta]m)*Maj[4].Maj[2])/2]*)
(*evals=FullSimplify@Eigenvalues[H0m]*)
(*params1={\[Epsilon]->1,\[Delta]p->1/10,\[Delta]m->1/100};*)
(**)
(*(*Identifying energy eigenvalues in particle-hole pairs.*)*)
(*\[Epsilon][1]=(evals[[4]]-evals[[2]]);*)
(*\[Epsilon][2]=(evals[[4]]+evals[[2]]);*)
(*\[Epsilon][-1]=-\[Epsilon][1];*)
(*\[Epsilon][-2]=-\[Epsilon][2];*)
(**)
(*(*The low-energy Hamiltonian in terms of fermionic operators.*)*)
(*Hf0=((\[Epsilon]*Cos[\[Phi]/2]*(Cre[1].Ann[1]-(1/2)Id[4])+I*\[Delta]p*Ann[1].Ann[2]+I*\[Delta]m*Cre[1].Ann[2]))/2;*)
(*Hf=Hf0+Dagger[Hf0];*)


(* ::Input:: *)
(*HfSys=Eigensystem[Hf];*)
(*HfVal=DiagonalMatrix[{HfSys[[1]][[3]],HfSys[[1]][[4]],HfSys[[1]][[2]],HfSys[[1]][[1]]}];*)
(*HfVec=(FullSimplify[Normalize/@({HfSys[[2]][[3]],HfSys[[2]][[4]],HfSys[[2]][[2]],HfSys[[2]][[1]]}),{\[Phi]>0,\[Epsilon]>\[Delta]p,\[Delta]p>\[Delta]m,\[Delta]m>0}])\[Transpose];//AbsoluteTiming*)
(*iHfVec=FullSimplify[Inverse[HfVec],{\[Phi]>0,\[Epsilon]>\[Delta]p,\[Delta]p>\[Delta]m,\[Delta]m>0}];//AbsoluteTiming*)
(**)
(*AndreevAnn[1]=iHfVec.Ann[1].HfVec;*)
(*AndreevAnn[2]=iHfVec.Ann[2].HfVec;*)
(*AndreevCre[1]=iHfVec.Cre[1].HfVec;*)
(*AndreevCre[2]=iHfVec.Cre[2].HfVec;*)
(**)
(*(*The low-energy Hamiltonian in terms of quasiparticle operators.*)*)
(*H\[Alpha]=Simplify@Sum[\[Epsilon][n]*(Cre[n].Ann[n]-(1/2)Id[4]),{n,1,2}];*)
(**)
(*(*Current operator.*)*)
(*CurHam=-I*(\[Epsilon]/2)*Sin[\[Phi]/2]*(AndreevCre[1]+AndreevAnn[1]).((1/I)(AndreevAnn[1]-AndreevCre[1]));*)


(* ::Input:: *)
(*(*Check relaxation rate estimate.*)*)
(*rateR=(8*(HfVal[[2,2]]-HfVal[[1,1]])Abs[Conjugate[HfVec[[2]]].D[HfVec[[1]],\[Phi]]]^2)/(25.81*10^3);*)
(*rateRspace=Reap[Do[*)
(*Sow[rateR/.{\[Epsilon]->1,\[Delta]p->1/100,\[Delta]m->1/1000,\[Phi]->\[Phi]\[Prime]}]*)
(*,{\[Phi]\[Prime],0,2\[Pi],2\[Pi]/29999}]][[2,1]];//AbsoluteTiming*)
(*rateRavg=Mean@rateRspace*)


(* ::Input:: *)
(*(*Particle-hole symmetry is enforced.*)*)
(*Cre[-1]=Ann[1];*)
(*Ann[-1]=Cre[1];*)
(*Cre[-2]=Ann[2];*)
(*Ann[-2]=Cre[2];*)
(**)
(*(*These are defined for convenience so that summation can span over the k=0 term without harm.*)*)
(*Cre[0]=ZeroMat[4];*)
(*Ann[0]=ZeroMat[4];*)
(**)
(*conIndices=DeleteCases[Range[-2,2],0];*)
(*\[Tau]3sgn=DiagonalMatrix[{-1,-1,1,1}].DiagonalMatrix[{-1,1,-1,1}];*)
(**)
(*(*Connections. Derivation excluded as it is lengthy.*)*)
(*mApprox[2,1]=(-I/2)(\[Epsilon]/4)(\[Delta]m/(\[Delta]m^2+\[Epsilon]^2*Cos[\[Phi]/2]^2))Sin[\[Phi]/2];*)
(*mApprox[-2,1]=(-I/2)(\[Epsilon]/4)(\[Delta]p/(\[Delta]p^2+\[Epsilon]^2*Cos[\[Phi]/2]^2))Sin[\[Phi]/2]-(1/4)((\[Epsilon]*Cos[\[Phi]/2]*(\[Epsilon]*Cos[\[Phi]/2]-\[Delta]p))/(\[Delta]p^2-2\[Delta]p*\[Epsilon]*Cos[\[Phi]/2]+2\[Epsilon]^2*Cos[\[Phi]/2]^2));*)
(**)
(*mApprox[2,2]=-(\[Epsilon]*\[Delta]p*Cos[\[Phi]/2]/(4(\[Delta]p*\[Delta]m+2\[Epsilon]^2*Cos[\[Phi]/2]^2)));*)
(*mApprox[1,1]=mApprox[2,2];*)
(*mApprox[-1,-2]=-mApprox[2,1];*)
(*mApprox[-1,2]=-mApprox[-2,1];*)
(**)
(*mApprox[-2,-2]=-mApprox[2,2];*)
(*mApprox[-1,-1]=-mApprox[1,1];*)
(**)
(*mApprox[1,2]=Conjugate@mApprox[2,1];*)
(*mApprox[1,-2]=Conjugate@mApprox[-2,1];*)
(*mApprox[-2,-1]=Conjugate@mApprox[-1,-2];*)
(*mApprox[2,-1]=Conjugate@mApprox[-1,2];*)
(**)
(*Do[mApprox[i,-i]=0,{i,conIndices}]*)
(**)
(*H0=Simplify[H\[Alpha]+(\[HBar])*sw*Sum[mApprox[m,n]*Cre[m].Ann[n],{m,-2,2},{n,-2,2}],{\[Delta]m>0,\[Delta]p>\[Delta]m,\[Epsilon]>\[Delta]p,\[Phi]\[Element]Reals}]*)


(* ::Input:: *)
(*MakeReal[\[HBar]];MakeReal[\[CapitalGamma]D];MakeReal[\[Omega]D];MakeReal[\[CapitalDelta]];MakeReal[Ec];MakeReal[\[CapitalGamma]0];MakeReal[sD];MakeReal[\[Phi]0];MakeReal[\[CapitalGamma]q];MakeReal[\[CapitalGamma]r];*)
(*MakeReal[\[CapitalGamma]d];*)
(**)
(*(*Parity operator and partial Fourier transform of correlation function as given by DOI: 10.1103/PhysRevB.88.144507.*)*)
(*powpar=Cre[1].Ann[1]+Cre[2].Ann[2];*)
(*par=MatrixExp[powpar*(-I*\[Pi])];*)
(*fA[k_]:=(I*\[HBar]*\[CapitalGamma]D*Log[((\[HBar]*\[Omega]D)^2-(\[Epsilon][k]-\[CapitalDelta]+(I*\[HBar]*\[CapitalGamma]0)/2)^2)/((\[HBar]*\[Omega]D)^2-(\[Epsilon][k]-Ec+(I*\[HBar]*\[CapitalGamma]0)/2)^2)]);*)
(**)
(*(*Build the generic density matrix \[Rho]Mat.*)
(*The Hamiltonian H0\[Prime] includes the Lamb shift term.*)*)
(*\[Rho]Mat=Simplify[Table[\[Rho][i,j][t],{i,1,4},{j,1,4}],{\[Phi]>0,\[Epsilon]>\[Delta]p,\[Delta]p>\[Delta]m,\[Delta]m>0}];*)
(*H0\[Prime]=H0+(I/2)*Sum[(fA[k\[Prime]]-Conjugate[fA[k]])*Cre[k].Ann[k\[Prime]],{k,1,2},{k\[Prime],1,2}];*)
(*unitary=-I*Commutator[H0\[Prime],\[Rho]Mat];*)
(*correlator=Simplify[(fA[k\[Prime]]+Conjugate[fA[k]]),TimeConstraint->1];*)
(*LindbladStandard=Ann[k\[Prime]].par.\[Rho]Mat.par.Cre[k]-(1/2)antiCommutator[Cre[k].Ann[k\[Prime]],\[Rho]Mat];*)
(**)
(*(*Phenomenological rate terms.*)*)
(*\[Chi][A_]:=(A.\[Rho]Mat.Dagger[A]-(1/2)antiCommutator[Dagger[A].A,\[Rho]Mat])*)
(*ratePoison=\[CapitalGamma]q*Sum[\[Chi][Ann[k].par],{k,-2,2}];*)
(*rateRelax=\[CapitalGamma]r(\[Chi][Ann[2].Ann[1]]+\[Chi][Cre[1].Ann[2]]);*)
(*rateDephase=\[CapitalGamma]d(Sin[\[Phi]/2]^2)Sum[\[Chi][Cre[k].Ann[k]],{k,1,2}];*)
(**)
(*(*Construct the density matrix.*)*)
(*\[Rho]DotMat=(unitary+Sum[correlator*LindbladStandard,{k,-2,2},{k\[Prime],-2,2}])+ratePoison+rateRelax+rateDephase;*)
(*\[Rho]Flat=Flatten@\[Rho]Mat;*)


(* ::Input:: *)
(*(*Final setup of the master equation and solution.*)*)
(*masterVec=Flatten@MapThread[Equal,{D[\[Rho]Mat,t],\[Rho]DotMat},2];*)
(**)
(*\[Phi]0min=0/2;*)
(*\[Phi]0max=\[Pi];*)
(*\[Phi]0steps=96;*)
(*\[Phi]0stepsize=(\[Phi]0max-\[Phi]0min)/(\[Phi]0steps-1);*)
(**)
(*\[Omega]Dmin=1/10;*)
(*\[Omega]Dmax=3/1;*)
(*\[Omega]Dsteps=64;*)
(*\[Omega]Dstepsize=(\[Omega]Dmax-\[Omega]Dmin)/(\[Omega]Dsteps-1);*)
(**)
(*unsortedCurrentMap=Reap[ParallelDo[*)
(*param={\[Epsilon]->1,\[Delta]p->(1/100)*\[Epsilon],\[Delta]m->(1/1000)*\[Epsilon],\[Phi]->\[Phi]0val+2sD*Cos[\[Omega]Dval*t],\[Phi]0->\[Phi]0val,sw->-2sD*\[Omega]Dval*Sin[\[Omega]Dval*t],sD->(1/10)*(\[Epsilon]/((\[HBar])*\[Omega]Dval)),\[Omega]D->\[Omega]Dval,\[CapitalGamma]0->(*10^(-2)*)10^(-3)*\[Epsilon],\[CapitalGamma]D->(*10^(-3)*)10^(-5),Ec->100,\[CapitalDelta]->(3/2)*(\[Epsilon]),\[HBar]->1,\[CapitalGamma]q->10^(-4)*(\[Epsilon]/(\[HBar])),\[CapitalGamma]r->10^(-4)*(\[Epsilon]/(\[HBar])),\[CapitalGamma]d->10^(-3)*(\[Epsilon]/(\[HBar]))};*)
(*period=(2\[Pi]/\[Omega]Dval);*)
(*exptTime=400period;*)
(**)
(*initialCond=(Flatten@(MapThread[Equal,{\[Rho]Mat,SparseArray[{{1,1}->1/3,{2,2}->1/3,{3,3}->1/6,{4,4}->1/6},{4,4}]},2])//.param)/.t->0;*)
(*syst=Join[masterVec,initialCond];*)
(**)
(*soln=NDSolve[syst//.param,\[Rho]Flat//.param,{t,exptTime-period,exptTime},MaxSteps->\[Infinity],Method->{"EquationSimplification"->"Solve"}];*)
(**)
(*initialT=exptTime-period;*)
(*finalT=exptTime;*)
(*tempInt=Chop[(2/(finalT-initialT))NIntegrate[Tr[(\[Rho]Mat.CurHam//.param)/.Flatten[soln]],{t,initialT,finalT},Method->{"GlobalAdaptive","SymbolicProcessing"->0,"MaxErrorIncreases"->2000},MaxRecursion->20,WorkingPrecision->120,PrecisionGoal->8,AccuracyGoal->Infinity],10^(-5)];*)
(*ParallelSow[{\[Phi]0val,\[Omega]Dval,tempInt}];*)
(*Clear[tempInt];*)
(*Clear[soln];*)
(*,{\[Phi]0val,\[Phi]0min,\[Phi]0max,\[Phi]0stepsize},{\[Omega]Dval,\[Omega]Dmin,\[Omega]Dmax,\[Omega]Dstepsize},Method->"FinestGrained"]][[2,1]];//AbsoluteTiming*)
(**)
(*currentMap=Sort[unsortedCurrentMap,(#1[[1]]<#2[[1]]||(#1[[1]]==#2[[1]]&&#1[[2]]<#2[[2]]))&];*)
(*Clear[unsortedCurrentMap];*)
(**)
(*spike1=Plot[(\[Epsilon][2]-\[Epsilon][1])/.{\[Epsilon]->1,\[Delta]m->1/1000},{\[Phi],0,\[Pi]},PlotStyle->{Black,Dashed}];*)
(*spike2=Plot[(1/2)(\[Epsilon][2]-\[Epsilon][1])/.{\[Epsilon]->1,\[Delta]m->1/1000},{\[Phi],0,\[Pi]},PlotStyle->{Black,Dashed}];*)
(*Show[ListDensityPlot[currentMap,PlotLegends->Automatic,ColorFunction->ColorData["FuchsiaTones"],AspectRatio->2/3],spike1,spike2]*)



